\documentclass{article} % Класс печатного документа

% для поддержки русского языка
\usepackage[T2A]{fontenc} % поддержка специальных русских символов
\usepackage[utf8]{inputenc} % Кодировка исходного текста - utf8
\usepackage[english,russian]{babel} % Поддержка языка - русского с английским
\usepackage{indentfirst} % Отступ в первом абзаце

\usepackage{hyperref} % Для вставки гиперссылок
% \usepackage{listings} % Для вставки кусков кода
\usepackage{graphicx} % Вставка изображений
\usepackage{subfig} % Изображения друг напротив друга
\usepackage{float} % Для точного позиционирования картинок
\usepackage[justification=centering]{caption} % Для центрирования подписей

\include{pythonstyle} % для красивого оформления python кода

% путь к папке с изображениями
\graphicspath{{./figs/}}

\title{Отчёт 11\\
Кластеризация и визуализация\\
методом самоорганизующихся карт Кохонена} % заголовок документа
\author{Свичкарев А.\,В.} % Автор документа
\date{\today} % Текущая дата

\begin{document} % Конец преамбулы, начало текста

\maketitle % Печатает заголовок, список авторов и дату

\section{Цель}
Изучить способы решения задач кластеризации и визуализации
методом самоорганизующихся карт Кохонена.

\section{Задание №1}
Написать программу построения
модели кластеризации данных методом
самоорганизующихся карт Кохонена.
В качестве входных данных использовать случайным
образом сгенерированный набор,
представленный матрицей 20*20 элементов.
Выполнить программу с различным числом итераций : 1, 10, 100 и
представить изображения полученных карт.
Оценить время и охарактеризовать полученные
карты при различных значениях числа итераций.

Реализация на основе кода программы из Приложения.
\pythonexternal{../exercise12.py}

\clearpage
Состояния карт (20x20) при различном числе итераций:
\begin{figure}[H]
	\centering
	\subfloat[Итерация 0]{\includegraphics[width=0.5\textwidth]{somap20-0.png}}
	\hfill
	\subfloat[Итерация 1]{\includegraphics[width=0.5\textwidth]{somap20-1.png}}
\end{figure}
\begin{figure}[H]
	\centering
	\subfloat[Итерация 10]{\includegraphics[width=0.5\textwidth]{somap20-10.png}}
	\hfill
	\subfloat[Итерация 100]{\includegraphics[width=0.5\textwidth]{somap20-100.png}}
\end{figure}
\bigskip

Показатели времени для размера матрицы 20х20:
\lstinputlisting[firstline=1, lastline=4]{ex12_out.txt}

\clearpage
\section{Задание №2}
Применить разработанную программу к набору данных, представленный матрицей
100*100 элементов. Выполнить программу с различным числом итераций : 1, 10, 100 и
представить изображения полученных карт.
Оценить время и охарактеризовать полученные карты
при различных значениях числа итераций.

Реализация на основе кода программы из Приложения.
\bigskip

Состояния карт (100x100) при различном числе итераций:
\begin{figure}[H]
	\centering
	\subfloat[Итерация 0]{\includegraphics[width=0.5\textwidth]{somap100-0.png}}
	\hfill
	\subfloat[Итерация 1]{\includegraphics[width=0.5\textwidth]{somap100-1.png}}
\end{figure}
\begin{figure}[H]
	\centering
	\subfloat[Итерация 10]{\includegraphics[width=0.5\textwidth]{somap100-10.png}}
	\hfill
	\subfloat[Итерация 100]{\includegraphics[width=0.5\textwidth]{somap100-100.png}}
\end{figure}

Показатели времени для размера матрицы 100х100:
\lstinputlisting[firstline=5, lastline=8]{ex12_out.txt}

С увеличением числа итераций пятна группируются,
становятся больше, при этом границы перестают иметь чётких границ.
Имеет место достаточно сильное перемещение пятен,
такое, что затруднительно предсказать как
будет выглядеть карта, зная как выглядит
относительно более ранняя по итерациям карта.

Асимптотическая сложность алгоритма линейна по числу итераций,
это видно если сравнивать показания времени для одного размера карты.
Они увеличиваются пропорционально увеличению числа итераций.

По алгоритму сложность квадратична от размера карты по одной оси,
т.е. для двумерной карты это квадрат размера по оси.
Однако число входных векторов так же изменяется как квадрат размера
карты по оси, то в конечном варианте сложность реализации
можно рассматривать как 4 степень от размера карты.
Но на деле время меньше при увеличение с 20 до 100,
можно предположить, что сказались оптимизации интерпретатора
и хорошее кэширование векторов.

По субъективным впечатлениям,
данный метод проигрывает как по качеству,
так и по времени работы различным
алгоритмам, основанным на бинарных деревьях решений.

\section{Пояснение}
Исходный код доступен по ссылке:
\href{https://github.com/SvichkarevAnatoly/Course-Python-Bioinformatics/tree/master/semester2/task11}
{github.com}

\end{document} % Конец документа
